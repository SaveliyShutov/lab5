# Отчет по лабораторной работе №5

## Содержание
1. [Общая структура проекта](#общая-структура-проекта)
2. [Задание 1: Кумулятивные префиксы](#задание-1-кумулятивные-префиксы)
3. [Задание 2: Матрица и строка с минимальной суммой](#задание-2-матрица-и-строка-с-минимальной-суммой)
4. [Задание 3: Фильтрация игрушек по возрасту](#задание-3-фильтрация-игрушек-по-возрасту)
5. [Задание 4: Произведение минимального и максимального](#задание-4-произведение-минимального-и-максимального)
6. [Задание 5: Подсчет нечетных элементов](#задание-5-подсчет-нечетных-элементов)
7. [Задание 6: Вычисление длин строк](#задание-6-вычисление-длин-строк)
8. [Тестирование и результаты](#тестирование-и-результаты)

---

## Общая структура проекта

### Основные классы и структуры

#### Структура Toy
```cpp
struct Toy {
    char name[64];           // Название игрушки (фиксированный размер)
    std::int32_t price;      // Стоимость в рублях
    std::int32_t min_age;    // Минимальный возраст
    std::int32_t max_age;    // Максимальный возраст
};
```

**Методы генерации файлов:**
- `GenerateBinaryNumbers()` - генерация бинарного файла со случайными числами
- `GenerateBinaryToys()` - генерация бинарного файла с данными об игрушках
- `GenerateTextIntegersOnePerLine()` - генерация текстового файла с числами по одному в строке
- `GenerateTextIntegersMultiplePerLine()` - генерация текстового файла с числами по несколько в строке
- `GenerateTextFileWithLines()` - генерация текстового файла с текстом

**Методы выполнения заданий:**
- `Task1_CumulativePrefixes()` - задание 1
- `Task2_MatrixClosestRow()` - задание 2
- `Task3_ToysForAges()` - задание 3
- `Task4_ProductMinMax()` - задание 4
- `Task5_CountOdd()` - задание 5
- `Task6_LineLengths()` - задание 6

#### Вспомогательная функция
```cpp
int RandomInt(int min_value, int max_value);
```
Генерирует случайное целое число в заданном диапазоне.

---

## Задание 1: Кумулятивные префиксы

### 1) Постановка задачи
**Цель:** Сформировать новый бинарный файл на основе исходного по следующему правилу: сначала записывается первый элемент исходного файла, затем — первый и второй, затем — первый, второй, третий, и т.д., на последнем шаге — все элементы исходного файла.

**Входные данные:**
- Исходный бинарный файл с целыми числами

**Выходные данные:**
- Результирующий бинарный файл с кумулятивными префиксами

### 2) Ход решения
**Метод:** `Task1_CumulativePrefixes(const std::string& src, const std::string& dest)`

**Алгоритм:**
1. Открытие исходного файла в бинарном режиме для чтения
2. Чтение всех чисел в вектор `vals`
3. Открытие выходного файла в бинарном режиме для записи
4. Для каждого `count` от 1 до размера вектора:
   - Запись первых `count` элементов в выходной файл

**Ключевые элементы кода:**
```cpp
while (in.read((char *)&x, sizeof(x))) {
    vals.push_back(x);
}

for (std::size_t count = 1; count <= vals.size(); ++count) {
    for (std::size_t i = 0; i < count; ++i) {
        out.write((char *)&vals[i], sizeof(vals[i]));
    }
}
```

### 3) Вывод программы
**Создаваемые файлы:**
- `numbers.bin` - исходный бинарный файл со случайными числами
- `prefixes.bin` - результирующий файл с кумулятивными префиксами

**Формат вывода:**
Программа не выводит результат на экран, но создает файл `prefixes.bin`, содержащий последовательность чисел по заданному правилу.

---

## Задание 2: Матрица и строка с минимальной суммой

### 1) Постановка задачи
**Цель:** Скопировать элементы заданного файла в квадратную матрицу размером n×n (если элементов файла недостает, заполнить оставшиеся элементы матрицы нулями). Указать строку (назвать её номер), где сумма элементов ближе всего к нулю.

**Входные данные:**
- Бинарный файл с целыми числами
- Размер матрицы n

**Выходные данные:**
- Номер строки (начиная с 1), сумма элементов которой ближе всего к нулю

### 2) Ход решения
**Метод:** `Task2_MatrixClosestRow(const std::string& src, std::size_t n)`

**Алгоритм:**
1. Чтение всех чисел из файла в вектор `data`
2. Дополнение вектора нулями до размера n×n
3. Для каждой строки матрицы:
   - Вычисление суммы элементов
   - Вычисление абсолютного значения суммы
   - Поиск строки с минимальным абсолютным значением суммы
4. Возврат номера строки (индекс + 1)

**Ключевые элементы кода:**
```cpp
while (data.size() < n * n) {
    data.push_back(0);
}

for (std::size_t row = 0; row < n; ++row) {
    long long sum = 0;
    for (std::size_t col = 0; col < n; ++col) {
        sum += data[row * n + col];
    }
    // ... сравнение с лучшей суммой
}
```

### 3) Вывод программы
**Вывод на экран:**
```
Row closest to zero: <номер_строки>
```

**Пример пути к файлу:**
`numbers.bin`

---

## Задание 3: Фильтрация игрушек по возрасту

### 1) Постановка задачи
**Цель:** Файл содержит сведения об игрушках: название игрушки, ее стоимость в рублях и возрастные границы. Получить названия игрушек, которые подходят детям как четырех лет, так и десяти лет.

**Входные данные:**
- Бинарный файл со структурой `Toy`

**Выходные данные:**
- Вектор строк с названиями подходящих игрушек

### 2) Ход решения
**Метод:** `Task3_ToysForAges(const std::string& src, int age1, int age2)`

**Алгоритм:**
1. Открытие бинарного файла с игрушками
2. Последовательное чтение структур `Toy`
3. Проверка для каждой игрушки:
   - `age1` должен быть в диапазоне [min_age, max_age]
   - `age2` должен быть в диапазоне [min_age, max_age]
4. Добавление названия подходящей игрушки в результат

**Ключевые элементы кода:**
```cpp
if (t.min_age <= age1 && age1 <= t.max_age && 
    t.min_age <= age2 && age2 <= t.max_age) {
    res.emplace_back(t.name);
}
```

### 3) Вывод программы
**Вывод на экран:**
```
Toys for 4 and 10:
  <Название_игрушки_1>
  <Название_игрушки_2>
  ...
```

**Пример пути к файлу:**
`toys.bin`

---

## Задание 4: Произведение минимального и максимального

### 1) Постановка задачи
**Цель:** В текстовом файле найти произведение максимального и минимального элементов.

**Входные данные:**
- Текстовый файл с целыми числами (по одному в строке)

**Выходные данные:**
- Произведение минимального и максимального элементов

### 2) Ход решения
**Метод:** `Task4_ProductMinMax(const std::string& filename)`

**Алгоритм:**
1. Открытие текстового файла
2. Инициализация переменных:
   - `minv` = максимальное значение типа `long long`
   - `maxv` = минимальное значение типа `long long`
3. Последовательное чтение чисел из файла
4. Обновление минимума и максимума
5. Возврат произведения `minv * maxv`

**Ключевые элементы кода:**
```cpp
long long minv = std::numeric_limits<long long>::max();
long long maxv = std::numeric_limits<long long>::min();

while (in >> x) {
    if (x < minv) minv = x;
    if (x > maxv) maxv = x;
}
```

### 3) Вывод программы
**Вывод на экран:**
```
Min*Max = <результат>
```

**Пример пути к файлу:**
`one_per_line.txt`

---

## Задание 5: Подсчет нечетных элементов

### 1) Постановка задачи
**Цель:** Вычислить количество нечётных элементов в текстовом файле.

**Входные данные:**
- Текстовый файл с целыми числами (по несколько в строке)

**Выходные данные:**
- Количество нечетных элементов

### 2) Ход решения
**Метод:** `Task5_CountOdd(const std::string& filename)`

**Алгоритм:**
1. Открытие текстового файла
2. Последовательное чтение чисел через оператор `>>`
3. Для каждого числа проверка нечетности: `(x & 1LL) != 0`
4. Подсчет нечетных чисел

**Ключевые элементы кода:**
```cpp
while (in >> x)
    if ((x & 1LL) != 0)
        ++cnt;
```

### 3) Вывод программы
**Вывод на экран:**
```
Odd count = <количество_нечетных>
```

**Пример пути к файлу:**
`multi_per_line.txt`

---

## Задание 6: Вычисление длин строк

### 1) Постановка задачи
**Цель:** Создать новый текстовый файл, каждая строка которого содержит длину строки исходного файла.

**Входные данные:**
- Текстовый файл с произвольным содержанием

**Выходные данные:**
- Текстовый файл с длинами строк

### 2) Ход решения
**Метод:** `Task6_LineLengths(const std::string& src, const std::string& dest)`

**Алгоритм:**
1. Открытие исходного файла для чтения
2. Открытие выходного файла для записи
3. Чтение строк из исходного файла с помощью `std::getline`
4. Запись длины каждой строки в выходной файл

**Ключевые элементы кода:**
```cpp
while (std::getline(in, line))
    out << line.size() << '\n';
```

### 3) Вывод программы
**Создаваемые файлы:**
- `lines.txt` - исходный текстовый файл
- `lengths.txt` - файл с длинами строк

**Пример содержимого `lengths.txt`:**
```
5
0
3
```

---

## Тестирование и результаты

### Основная функция main()
**Структура выполнения:**
1. Инициализация генератора случайных чисел
2. Создание файлов с тестовыми данными
3. Последовательное выполнение всех заданий
4. Вывод результатов на экран
5. Обработка исключений

**Ключевые переменные в main():**
```cpp
const std::string nums = "numbers.bin";          // Для заданий 1 и 2
const std::string prefixes = "prefixes.bin";     // Результат задания 1
const std::string toys = "toys.bin";             // Для задания 3
const std::string one_per = "one_per_line.txt";  // Для задания 4
const std::string multi = "multi_per_line.txt";  // Для задания 5
const std::string lines = "lines.txt";           // Для задания 6
const std::string lengths = "lengths.txt";       // Результат задания 6
```

### Обработка ошибок
Все методы используют исключения для обработки ошибок:
- `std::runtime_error` - ошибки ввода/вывода файлов
- `std::invalid_argument` - некорректные аргументы методов

### Зависимости проекта
Для компиляции проекта необходимы следующие заголовочные файлы:
- `<fstream>` - работа с файлами
- `<vector>` - динамические массивы
- `<algorithm>` - алгоритмы STL
- `<limits>` - пределы типов данных
- `<cstring>` - функции работы со строками C
- `<cstdlib>`, `<ctime>` - генерация случайных чисел

---

## Заключение

Данный проект демонстрирует различные аспекты работы с файлами в C++:
- Работа с бинарными файлами (задания 1-3)
- Работа с текстовыми файлами (задания 4-6)
- Обработка структурированных данных (задание 3)
- Реализация алгоритмов обработки данных

Все задания выполнены в соответствии с требованиями, код структурирован, содержит обработку ошибок и комментарии для понимания логики работы.